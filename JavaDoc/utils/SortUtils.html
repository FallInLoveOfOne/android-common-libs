<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
        "http://www.w3.org/TR/html4/loose.dtd">
<!-- NewPage -->
<html lang="en">
<head>
    <!-- Generated by javadoc (1.8.0_112) on Wed Aug 02 23:48:38 CST 2017 -->
    <title>SortUtils</title>
    <meta name="date" content="2017-08-02">
    <link rel="stylesheet" type="text/css" href="../../../stylesheet.css" title="Style">
    <script type="text/javascript" src="../../../script.js"></script>
</head>
<body>
<script type="text/javascript"><!--
    try {
        if (location.href.indexOf('is-external=true') == -1) {
            parent.document.title="SortUtils";
        }
    }
    catch(err) {
    }
//-->
var methods = {"i0":9,"i1":9,"i2":9,"i3":9,"i4":9,"i5":9,"i6":9,"i7":9,"i8":9};
var tabs = {65535:["t0","All Methods"],1:["t1","Static Methods"],8:["t4","Concrete Methods"]};
var altColor = "altColor";
var rowColor = "rowColor";
var tableTab = "tableTab";
var activeTableTab = "activeTableTab";

</script>
<noscript>
    <div>JavaScript is disabled on your browser.</div>
</noscript>
<!-- ========= START OF TOP NAVBAR ======= -->
<div class="topNav"><a name="navbar.top">
    <!--   -->
</a>
    <div class="skipNav"><a href="#skip.navbar.top" title="Skip navigation links">Skip navigation
        links</a></div>
    <a name="navbar.top.firstrow">
        <!--   -->
    </a>
    <ul class="navList" title="Navigation">
        <li><a href="../../../overview-summary.html">Overview</a></li>
        <li><a href="package-summary.html">Package</a></li>
        <li class="navBarCell1Rev">Class</li>
        <li><a href="package-tree.html">Tree</a></li>
        <li><a href="../../../deprecated-list.html">Deprecated</a></li>
        <li><a href="../../../index-files/index-1.html">Index</a></li>
        <li><a href="../../../help-doc.html">Help</a></li>
    </ul>
</div>
<div class="subNav">
    <ul class="navList">
        <li><a href="../../../waterhole/commonlibs/utils/SecurityUtils.html"
               title="class in waterhole.commonlibs.utils"><span class="typeNameLink">Prev&nbsp;Class</span></a>
        </li>
        <li><a href="../../../waterhole/commonlibs/utils/StringUtils.html"
               title="class in waterhole.commonlibs.utils"><span class="typeNameLink">Next&nbsp;Class</span></a>
        </li>
    </ul>
    <ul class="navList">
        <li><a href="../../../index.html?waterhole/commonlibs/utils/SortUtils.html" target="_top">Frames</a>
        </li>
        <li><a href="SortUtils.html" target="_top">No&nbsp;Frames</a></li>
    </ul>
    <ul class="navList" id="allclasses_navbar_top">
        <li><a href="../../../allclasses-noframe.html">All&nbsp;Classes</a></li>
    </ul>
    <div>
        <script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_top");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->

        </script>
    </div>
    <div>
        <ul class="subNavList">
            <li>Summary:&nbsp;</li>
            <li>Nested&nbsp;|&nbsp;</li>
            <li>Field&nbsp;|&nbsp;</li>
            <li><a href="#constructor.summary">Constr</a>&nbsp;|&nbsp;</li>
            <li><a href="#method.summary">Method</a></li>
        </ul>
        <ul class="subNavList">
            <li>Detail:&nbsp;</li>
            <li>Field&nbsp;|&nbsp;</li>
            <li><a href="#constructor.detail">Constr</a>&nbsp;|&nbsp;</li>
            <li><a href="#method.detail">Method</a></li>
        </ul>
    </div>
    <a name="skip.navbar.top">
        <!--   -->
    </a></div>
<!-- ========= END OF TOP NAVBAR ========= -->
<!-- ======== START OF CLASS DATA ======== -->
<div class="header">
    <div class="subTitle">waterhole.commonlibs.utils</div>
    <h2 title="Class SortUtils" class="title">Class SortUtils</h2>
</div>
<div class="contentContainer">
    <ul class="inheritance">
        <li>java.lang.Object</li>
        <li>
            <ul class="inheritance">
                <li>waterhole.commonlibs.utils.SortUtils</li>
            </ul>
        </li>
    </ul>
    <div class="description">
        <ul class="blockList">
            <li class="blockList">
                <hr>
                <br>
                <pre>public final class <span class="typeNameLabel">SortUtils</span>
extends java.lang.Object</pre>
                <div class="block">排序工具类</div>
            </li>
        </ul>
    </div>
    <div class="summary">
        <ul class="blockList">
            <li class="blockList">
                <!-- ======== CONSTRUCTOR SUMMARY ======== -->
                <ul class="blockList">
                    <li class="blockList"><a name="constructor.summary">
                        <!--   -->
                    </a>
                        <h3>Constructor Summary</h3>
                        <table class="memberSummary" border="0" cellpadding="3" cellspacing="0"
                               summary="Constructor Summary table, listing constructors, and an explanation">
                            <caption><span>Constructors</span><span class="tabEnd">&nbsp;</span>
                            </caption>
                            <tr>
                                <th class="colOne" scope="col">Constructor and Description</th>
                            </tr>
                            <tr class="altColor">
                                <td class="colOne"><code><span class="memberNameLink"><a
                                        href="../../../waterhole/commonlibs/utils/SortUtils.html#SortUtils--">SortUtils</a></span>()</code>&nbsp;
                                </td>
                            </tr>
                        </table>
                    </li>
                </ul>
                <!-- ========== METHOD SUMMARY =========== -->
                <ul class="blockList">
                    <li class="blockList"><a name="method.summary">
                        <!--   -->
                    </a>
                        <h3>Method Summary</h3>
                        <table class="memberSummary" border="0" cellpadding="3" cellspacing="0"
                               summary="Method Summary table, listing methods, and an explanation">
                            <caption><span id="t0"
                                           class="activeTableTab"><span>All Methods</span><span
                                    class="tabEnd">&nbsp;</span></span><span id="t1"
                                                                             class="tableTab"><span><a
                                    href="javascript:show(1);">Static Methods</a></span><span
                                    class="tabEnd">&nbsp;</span></span><span id="t4"
                                                                             class="tableTab"><span><a
                                    href="javascript:show(8);">Concrete Methods</a></span><span
                                    class="tabEnd">&nbsp;</span></span></caption>
                            <tr>
                                <th class="colFirst" scope="col">Modifier and Type</th>
                                <th class="colLast" scope="col">Method and Description</th>
                            </tr>
                            <tr id="i0" class="altColor">
                                <td class="colFirst"><code>static void</code></td>
                                <td class="colLast"><code><span class="memberNameLink"><a
                                        href="../../../waterhole/commonlibs/utils/SortUtils.html#bubbleSort-int:A-">bubbleSort</a></span>(int[]&nbsp;numbers)</code>
                                    <div class="block">比较相邻的元素。如果第一个比第二个大，就交换他们两个。
                                        对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。在这一点，最后的元素应该会是最大的数。
                                        针对所有的元素重复以上的步骤，除了最后一个。
                                        持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。
                                    </div>
                                </td>
                            </tr>
                            <tr id="i1" class="rowColor">
                                <td class="colFirst"><code>static boolean</code></td>
                                <td class="colLast"><code><span class="memberNameLink"><a
                                        href="../../../waterhole/commonlibs/utils/SortUtils.html#duplicates-java.lang.Object:A-">duplicates</a></span>(java.lang.Object[]&nbsp;a)</code>
                                    <div class="block">
                                        找出一个数组中是否有重复元素，给出最坏情况就是遍历的二次简单方法。但是如果我们对数组进行排序，
                                        则重复元素必定相邻，通过单一时间扫描就能检测到重复元素，排序时间在这个算法中占主导作用。
                                    </div>
                                </td>
                            </tr>
                            <tr id="i2" class="altColor">
                                <td class="colFirst"><code>static void</code></td>
                                <td class="colLast"><code><span class="memberNameLink"><a
                                        href="../../../waterhole/commonlibs/utils/SortUtils.html#heapSort-int:A-">heapSort</a></span>(int[]&nbsp;a)</code>
                                    <div class="block">堆排序

                                        堆排序是一种树形选择排序，是对直接选择排序的有效改进。
                                        堆的定义下：具有n个元素的序列
                                        （h1,h2,...,hn),当且仅当满足（hi>=h2i,hi>=2i+1）或（hi<=h2i,hi<=2i+1）
                                        (i=1,2,...,n/2)时称之为堆。
                                        在这里只讨论满足前者条件的堆。由堆的定义可以看出，堆顶元素（即第一个元素）必为最大项（大顶堆）。
                                        完全二叉树可以很直观地表示堆的结构。堆顶为根，其它为左子树、右子树。

                                        思想:
                                        初始时把要排序的数的序列看作是一棵顺序存储的二叉树，调整它们的存储序，使之成为一个堆，
                                        这时堆的根节点的数最大。然后将根节点与堆的最后一个节点交换。然后对前面(n-1)个数重新调整使之成为堆。
                                        依此类推，直到只有两个节点的堆，并对 它们作交换，最后得到有n个节点的有序序列。
                                        从算法描述来看，堆排序需要两个过程，一是建立堆，二是堆顶与堆的最后一个元素交换位置。
                                        所以堆排序有两个函数组成。一是建堆的渗透函数，二是反复调用渗透函数实现排序的函数。
                                    </div>
                                </td>
                            </tr>
                            <tr id="i3" class="rowColor">
                                <td class="colFirst"><code>static &lt;AnyType extends
                                    java.lang.Comparable&lt;? super AnyType&gt;&gt;<br>void</code>
                                </td>
                                <td class="colLast"><code><span class="memberNameLink"><a
                                        href="../../../waterhole/commonlibs/utils/SortUtils.html#insertSort-java.util.List-">insertSort</a></span>(java.util.List&lt;AnyType&gt;&nbsp;list)</code>
                                    <div class="block">插入排序

                                        插入排序是一种简单的排序，适用于少量数据。如果只是对几个元素排序，插入排序是是一种很好的解决方案。
                                        因为插入排序是这么短的算法，并且排序的时间不成问题。不过我们要处理大量数据，插入排序不是一种好的选择。

                                        插入排序的工作原理，第一个元素自身是有序的，每一个元素都比较一下。

                                        每步将一个待排序的记录，按其顺序码大小插入到前面已经排序的字序列的合适位置
                                        （从后向前找到合适位置后），直到全部插入排序完为止。
                                    </div>
                                </td>
                            </tr>
                            <tr id="i4" class="altColor">
                                <td class="colFirst"><code>static &lt;AnyType extends
                                    java.lang.Comparable&lt;? super AnyType&gt;&gt;<br>void</code>
                                </td>
                                <td class="colLast"><code><span class="memberNameLink"><a
                                        href="../../../waterhole/commonlibs/utils/SortUtils.html#mergeSort-AnyType:A-">mergeSort</a></span>(AnyType[]&nbsp;a)</code>
                                    <div class="block">归并排序

                                        归并排序的步骤分为三步：
                                        1.如果待p排序的个数为0或1，则直接返回。
                                        2.分别递归地对前半部分和后半部分排序。
                                        3.将两个有序部分归并成一个有序组。

                                        我们将学习如何将两个数组进行归并，并将结果放在第三个数组中。

                                        尽管归并排序的时间复杂度为O(Nlog(N))，但是空间复杂度高，归并需要两个额外的数组，在整个算法中，还有一个
                                        额外的操作，就是将元素数组复制到临时数组，再将临时数组复制回原数组，这会大大降低排序速度。
                                        通过在递归中交替层明智而谨慎地切换a和tmpArray的角色，就可以避免这种复制。

                                        归并排序的运行时间很大程度上取决于在数组和临时数组中比较元素和移动元素的代价。
                                        在java中，在通过对对象进行排序时，元素代价比较大，因此在通用设置中，是通过函数对象对元素进行比较。
                                        另一方面，移动元素的代价比较小，因为不进行元素的复制，而只是简单的引用改变。

                                        在所有流行算法中，归并排序的比较次数最少，因而在java中，它是通用算法的最佳算法。
                                        在java中，Arrays.sort()，对象数组使用的排序就是归并排序。这些基本相对代价既不适合于其他语言，
                                        也不适合于java的基本数据类型。另一种可选的排序方法是快速排序算法。Arrays.sort()对基本数据类型的排序
                                        采用的就是快速排序。
                                    </div>
                                </td>
                            </tr>
                            <tr id="i5" class="rowColor">
                                <td class="colFirst"><code>static void</code></td>
                                <td class="colLast"><code><span class="memberNameLink"><a
                                        href="../../../waterhole/commonlibs/utils/SortUtils.html#quickSort-int:A-">quickSort</a></span>(int[]&nbsp;array)</code>
                                    <div class="block">快速排序

                                        快速排序和归并排序都使用分治法来设计算法，区别在于归并排序把数组分为两个基本等长的子数组，
                                        分别排好序之后还要进行归并(Merge)操作，而快速排序拆分子数组的时候显得更有艺术，取一个基准元素，
                                        拆分之后基准元素左边的元素都比基准元素小，右边的元素都不小于基准元素，
                                        这样只需要分别对两个子数组排序即可，不再像归并排序一样需要归并操作。
                                        基准元素的选取对算法的效率影响很大，最好的情况是两个子数组大小基本相当。
                                        为简单起见，我们选择最后一个元素，更高级的做法可以先找一个中位数并把中位数与最后一个元素交换，
                                        之后再进行相同的操作步骤。

                                        拆分是快速排序的核心。快速排序的最坏运行时间是O(n2)，但期望的运行时间是O(nlgn)。


                                        快速排序算法Java实现:
                                        1.把数组拆分为两个子数组加上一个基准元素:
                                        选取最后一个元素作为基准元素，index变量记录最近一个小于基准元素的元素所在的位置，初始化为start-
                                        1，发现新的小于基准元素的元素，index加1。从第一个元素到倒数第二个元素，依次与基准元素比较，小于基准元素，index加1，交换位置index和当前位置的元素。循环结束之后index+1得到基准元素应该在的位置，交换index+1和最后一个元素。
                                        2.
                                    </div>
                                </td>
                            </tr>
                            <tr id="i6" class="altColor">
                                <td class="colFirst"><code>static void</code></td>
                                <td class="colLast"><code><span class="memberNameLink"><a
                                        href="../../../waterhole/commonlibs/utils/SortUtils.html#radixSort-int:A-int-int-">radixSort</a></span>(int[]&nbsp;data,
                                    int&nbsp;radix,
                                    int&nbsp;d)</code>
                                    <div class="block">桶排序/基数排序

                                        基本思想：是将阵列分到有限数量的桶子里。每个桶子再个别排序（有可能再使用别的排序算法或是以递回方式继续使用桶排序进行排序）。
                                        桶排序是鸽巢排序的一种归纳结果。当要被排序的阵列内的数值是均匀分配的时候，桶排序使用线性时间（Θ（n））。
                                        但桶排序并不是 比较排序，他不受到 O(n log n) 下限的影响。
                                        简单来说，就是把数据分组，放在一个个的桶中，然后对每个桶里面的在进行排序。

                                        例如要对大小为[1..1000]范围内的n个整数A[1..n]排序
                                        首先，可以把桶设为大小为10的范围，具体而言，设集合B[1]存储[1..10]的整数，集合B[2]存储
                                        (10..20]的整数，……集合B[i]存储( (i-1)*10, i*10]的整数，i = 1,2,..100。总共有
                                        100个桶。
                                        然后，对A[1..n]从头到尾扫描一遍，把每个A[i]放入对应的桶B[j]中。
                                        再对这100个桶中每个桶里的数字排序，这时可用冒泡，选择，乃至快排，一般来说任 何排序法都可以。
                                        最后，依次输出每个桶里面的数字，且每个桶中的数字从小到大输出，这 样就得到所有数字排好序的一个序列了。
                                        假设有n个数字，有m个桶，如果数字是平均分布的，则每个桶里面平均有n/m个数字。如果
                                        对每个桶中的数字采用快速排序，那么整个算法的复杂度是
                                        O(n + m * n/m*log(n/m)) = O(n + nlogn - nlogm)
                                        从上式看出，当m接近n的时候，桶排序复杂度接近O(n)

                                        当然，以上复杂度的计算是基于输入的n个数字是平均分布这个假设的。这个假设是很强的，
                                        实际应用中效果并没有这么好。如果所有的数字都落在同一个桶中，那就退化成一般的排序了。
                                        前面说的几大排序算法 ，大部分时间复杂度都是O（n2），也有部分排序算法时间复杂度是O(nlogn)。
                                        而桶式排序却能实现O（n）的时间复杂度。但桶排序的缺点是：

                                        1）首先是空间复杂度比较高，需要的额外开销大。排序有两个数组的空间开销，一个存放待排序数组，
                                        一个就是所谓的桶，比如待排序值是从0到m-1，那就需要m个桶，这个桶数组就要至少m个空间。
                                        2）其次待排序的元素都要在一定的范围内等等。
                                        桶式排序是一种分配排序。分配排序的特定是不需要进行关键码的比较，但前提是要知道待排序列的一些具体情况。
                                    </div>
                                </td>
                            </tr>
                            <tr id="i7" class="rowColor">
                                <td class="colFirst"><code>static void</code></td>
                                <td class="colLast"><code><span class="memberNameLink"><a
                                        href="../../../waterhole/commonlibs/utils/SortUtils.html#selectSort-int:A-">selectSort</a></span>(int[]&nbsp;numbers)</code>
                                    <div class="block">选择排序算法
                                        在未排序序列中找到最小或最大元素，存放到排序序列的起始位置
                                        再从剩余未排序元素中继续寻找最小元素，然后放到排序序列末尾。
                                        以此类推，直到所有元素均排序完毕。
                                    </div>
                                </td>
                            </tr>
                            <tr id="i8" class="altColor">
                                <td class="colFirst"><code>static &lt;AnyType extends
                                    java.lang.Comparable&lt;? super AnyType&gt;&gt;<br>void</code>
                                </td>
                                <td class="colLast"><code><span class="memberNameLink"><a
                                        href="../../../waterhole/commonlibs/utils/SortUtils.html#shellSort-java.util.List-">shellSort</a></span>(java.util.List&lt;AnyType&gt;&nbsp;list)</code>
                                    <div class="block">希尔排序</div>
                                </td>
                            </tr>
                        </table>
                        <ul class="blockList">
                            <li class="blockList"><a
                                    name="methods.inherited.from.class.java.lang.Object">
                                <!--   -->
                            </a>
                                <h3>Methods inherited from class&nbsp;java.lang.Object</h3>
                                <code>clone, equals, finalize, getClass, hashCode, notify,
                                    notifyAll, toString, wait, wait, wait</code></li>
                        </ul>
                    </li>
                </ul>
            </li>
        </ul>
    </div>
    <div class="details">
        <ul class="blockList">
            <li class="blockList">
                <!-- ========= CONSTRUCTOR DETAIL ======== -->
                <ul class="blockList">
                    <li class="blockList"><a name="constructor.detail">
                        <!--   -->
                    </a>
                        <h3>Constructor Detail</h3>
                        <a name="SortUtils--">
                            <!--   -->
                        </a>
                        <ul class="blockListLast">
                            <li class="blockList">
                                <h4>SortUtils</h4>
                                <pre>public&nbsp;SortUtils()</pre>
                            </li>
                        </ul>
                    </li>
                </ul>
                <!-- ============ METHOD DETAIL ========== -->
                <ul class="blockList">
                    <li class="blockList"><a name="method.detail">
                        <!--   -->
                    </a>
                        <h3>Method Detail</h3>
                        <a name="duplicates-java.lang.Object:A-">
                            <!--   -->
                        </a>
                        <ul class="blockList">
                            <li class="blockList">
                                <h4>duplicates</h4>
                                <pre>public static&nbsp;boolean&nbsp;duplicates(java.lang.Object[]&nbsp;a)</pre>
                                <div class="block">找出一个数组中是否有重复元素，给出最坏情况就是遍历的二次简单方法。但是如果我们对数组进行排序，
                                    则重复元素必定相邻，通过单一时间扫描就能检测到重复元素，排序时间在这个算法中占主导作用。
                                </div>
                            </li>
                        </ul>
                        <a name="insertSort-java.util.List-">
                            <!--   -->
                        </a>
                        <ul class="blockList">
                            <li class="blockList">
                                <h4>insertSort</h4>
                                <pre>public static&nbsp;&lt;AnyType extends java.lang.Comparable&lt;? super AnyType&gt;&gt;&nbsp;void&nbsp;insertSort(java.util.List&lt;AnyType&gt;&nbsp;list)</pre>
                                <div class="block">插入排序

                                    插入排序是一种简单的排序，适用于少量数据。如果只是对几个元素排序，插入排序是是一种很好的解决方案。
                                    因为插入排序是这么短的算法，并且排序的时间不成问题。不过我们要处理大量数据，插入排序不是一种好的选择。

                                    插入排序的工作原理，第一个元素自身是有序的，每一个元素都比较一下。

                                    每步将一个待排序的记录，按其顺序码大小插入到前面已经排序的字序列的合适位置
                                    （从后向前找到合适位置后），直到全部插入排序完为止。
                                </div>
                            </li>
                        </ul>
                        <a name="shellSort-java.util.List-">
                            <!--   -->
                        </a>
                        <ul class="blockList">
                            <li class="blockList">
                                <h4>shellSort</h4>
                                <pre>public static&nbsp;&lt;AnyType extends java.lang.Comparable&lt;? super AnyType&gt;&gt;&nbsp;void&nbsp;shellSort(java.util.List&lt;AnyType&gt;&nbsp;list)</pre>
                                <div class="block">希尔排序
                                    <p> 希尔排序是次二次算法，它的代码只比插入排序多一点，是更快算法中最简单的算法
                                        希尔排序避免大量的数据移动，通过先比较相距较远的元素，再比较相对较近的元素。</div>
                                <dl>
                                    <dt><span class="paramLabel">Parameters:</span></dt>
                                    <dd><code>list</code> - 集合</dd>
                                </dl>
                            </li>
                        </ul>
                        <a name="mergeSort-java.lang.Comparable:A-">
                            <!--   -->
                        </a><a name="mergeSort-AnyType:A-">
                            <!--   -->
                        </a>
                        <ul class="blockList">
                            <li class="blockList">
                                <h4>mergeSort</h4>
                                <pre>public static&nbsp;&lt;AnyType extends java.lang.Comparable&lt;? super AnyType&gt;&gt;&nbsp;void&nbsp;mergeSort(AnyType[]&nbsp;a)</pre>
                                <div class="block">归并排序

                                    归并排序的步骤分为三步：
                                    1.如果待p排序的个数为0或1，则直接返回。
                                    2.分别递归地对前半部分和后半部分排序。
                                    3.将两个有序部分归并成一个有序组。

                                    我们将学习如何将两个数组进行归并，并将结果放在第三个数组中。

                                    尽管归并排序的时间复杂度为O(Nlog(N))，但是空间复杂度高，归并需要两个额外的数组，在整个算法中，还有一个
                                    额外的操作，就是将元素数组复制到临时数组，再将临时数组复制回原数组，这会大大降低排序速度。
                                    通过在递归中交替层明智而谨慎地切换a和tmpArray的角色，就可以避免这种复制。

                                    归并排序的运行时间很大程度上取决于在数组和临时数组中比较元素和移动元素的代价。
                                    在java中，在通过对对象进行排序时，元素代价比较大，因此在通用设置中，是通过函数对象对元素进行比较。
                                    另一方面，移动元素的代价比较小，因为不进行元素的复制，而只是简单的引用改变。

                                    在所有流行算法中，归并排序的比较次数最少，因而在java中，它是通用算法的最佳算法。
                                    在java中，Arrays.sort()，对象数组使用的排序就是归并排序。这些基本相对代价既不适合于其他语言，
                                    也不适合于java的基本数据类型。另一种可选的排序方法是快速排序算法。Arrays.sort()对基本数据类型的排序
                                    采用的就是快速排序。
                                </div>
                            </li>
                        </ul>
                        <a name="quickSort-int:A-">
                            <!--   -->
                        </a>
                        <ul class="blockList">
                            <li class="blockList">
                                <h4>quickSort</h4>
                                <pre>public static&nbsp;void&nbsp;quickSort(int[]&nbsp;array)</pre>
                                <div class="block">快速排序

                                    快速排序和归并排序都使用分治法来设计算法，区别在于归并排序把数组分为两个基本等长的子数组，
                                    分别排好序之后还要进行归并(Merge)操作，而快速排序拆分子数组的时候显得更有艺术，取一个基准元素，
                                    拆分之后基准元素左边的元素都比基准元素小，右边的元素都不小于基准元素，
                                    这样只需要分别对两个子数组排序即可，不再像归并排序一样需要归并操作。
                                    基准元素的选取对算法的效率影响很大，最好的情况是两个子数组大小基本相当。
                                    为简单起见，我们选择最后一个元素，更高级的做法可以先找一个中位数并把中位数与最后一个元素交换，
                                    之后再进行相同的操作步骤。

                                    拆分是快速排序的核心。快速排序的最坏运行时间是O(n2)，但期望的运行时间是O(nlgn)。


                                    快速排序算法Java实现:
                                    1.把数组拆分为两个子数组加上一个基准元素:
                                    选取最后一个元素作为基准元素，index变量记录最近一个小于基准元素的元素所在的位置，初始化为start-
                                    1，发现新的小于基准元素的元素，index加1。从第一个元素到倒数第二个元素，依次与基准元素比较，小于基准元素，index加1，交换位置index和当前位置的元素。循环结束之后index+1得到基准元素应该在的位置，交换index+1和最后一个元素。
                                    2. 分别排序[start, index], 和[index+2, end]两个子数组
                                </div>
                            </li>
                        </ul>
                        <a name="bubbleSort-int:A-">
                            <!--   -->
                        </a>
                        <ul class="blockList">
                            <li class="blockList">
                                <h4>bubbleSort</h4>
                                <pre>public static&nbsp;void&nbsp;bubbleSort(int[]&nbsp;numbers)</pre>
                                <div class="block">比较相邻的元素。如果第一个比第二个大，就交换他们两个。
                                    对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。在这一点，最后的元素应该会是最大的数。
                                    针对所有的元素重复以上的步骤，除了最后一个。
                                    持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。
                                </div>
                                <dl>
                                    <dt><span class="paramLabel">Parameters:</span></dt>
                                    <dd><code>numbers</code> - 需要排序的整型数组</dd>
                                </dl>
                            </li>
                        </ul>
                        <a name="selectSort-int:A-">
                            <!--   -->
                        </a>
                        <ul class="blockList">
                            <li class="blockList">
                                <h4>selectSort</h4>
                                <pre>public static&nbsp;void&nbsp;selectSort(int[]&nbsp;numbers)</pre>
                                <div class="block">选择排序算法
                                    在未排序序列中找到最小或最大元素，存放到排序序列的起始位置
                                    再从剩余未排序元素中继续寻找最小元素，然后放到排序序列末尾。
                                    以此类推，直到所有元素均排序完毕。
                                </div>
                            </li>
                        </ul>
                        <a name="heapSort-int:A-">
                            <!--   -->
                        </a>
                        <ul class="blockList">
                            <li class="blockList">
                                <h4>heapSort</h4>
                                <pre>public static&nbsp;void&nbsp;heapSort(int[]&nbsp;a)</pre>
                                <div class="block">堆排序

                                    堆排序是一种树形选择排序，是对直接选择排序的有效改进。
                                    堆的定义下：具有n个元素的序列
                                    （h1,h2,...,hn),当且仅当满足（hi>=h2i,hi>=2i+1）或（hi<=h2i,hi<=2i+1）
                                    (i=1,2,...,n/2)时称之为堆。
                                    在这里只讨论满足前者条件的堆。由堆的定义可以看出，堆顶元素（即第一个元素）必为最大项（大顶堆）。
                                    完全二叉树可以很直观地表示堆的结构。堆顶为根，其它为左子树、右子树。

                                    思想:
                                    初始时把要排序的数的序列看作是一棵顺序存储的二叉树，调整它们的存储序，使之成为一个堆，
                                    这时堆的根节点的数最大。然后将根节点与堆的最后一个节点交换。然后对前面(n-1)个数重新调整使之成为堆。
                                    依此类推，直到只有两个节点的堆，并对 它们作交换，最后得到有n个节点的有序序列。
                                    从算法描述来看，堆排序需要两个过程，一是建立堆，二是堆顶与堆的最后一个元素交换位置。
                                    所以堆排序有两个函数组成。一是建堆的渗透函数，二是反复调用渗透函数实现排序的函数。
                                </div>
                            </li>
                        </ul>
                        <a name="radixSort-int:A-int-int-">
                            <!--   -->
                        </a>
                        <ul class="blockListLast">
                            <li class="blockList">
                                <h4>radixSort</h4>
                                <pre>public static&nbsp;void&nbsp;radixSort(int[]&nbsp;data,
                             int&nbsp;radix,
                             int&nbsp;d)</pre>
                                <div class="block">桶排序/基数排序

                                    基本思想：是将阵列分到有限数量的桶子里。每个桶子再个别排序（有可能再使用别的排序算法或是以递回方式继续使用桶排序进行排序）。
                                    桶排序是鸽巢排序的一种归纳结果。当要被排序的阵列内的数值是均匀分配的时候，桶排序使用线性时间（Θ（n））。
                                    但桶排序并不是 比较排序，他不受到 O(n log n) 下限的影响。
                                    简单来说，就是把数据分组，放在一个个的桶中，然后对每个桶里面的在进行排序。

                                    例如要对大小为[1..1000]范围内的n个整数A[1..n]排序
                                    首先，可以把桶设为大小为10的范围，具体而言，设集合B[1]存储[1..10]的整数，集合B[2]存储
                                    (10..20]的整数，……集合B[i]存储( (i-1)*10, i*10]的整数，i = 1,2,..100。总共有
                                    100个桶。
                                    然后，对A[1..n]从头到尾扫描一遍，把每个A[i]放入对应的桶B[j]中。
                                    再对这100个桶中每个桶里的数字排序，这时可用冒泡，选择，乃至快排，一般来说任 何排序法都可以。
                                    最后，依次输出每个桶里面的数字，且每个桶中的数字从小到大输出，这 样就得到所有数字排好序的一个序列了。
                                    假设有n个数字，有m个桶，如果数字是平均分布的，则每个桶里面平均有n/m个数字。如果
                                    对每个桶中的数字采用快速排序，那么整个算法的复杂度是
                                    O(n + m * n/m*log(n/m)) = O(n + nlogn - nlogm)
                                    从上式看出，当m接近n的时候，桶排序复杂度接近O(n)

                                    当然，以上复杂度的计算是基于输入的n个数字是平均分布这个假设的。这个假设是很强的，
                                    实际应用中效果并没有这么好。如果所有的数字都落在同一个桶中，那就退化成一般的排序了。
                                    前面说的几大排序算法 ，大部分时间复杂度都是O（n2），也有部分排序算法时间复杂度是O(nlogn)。
                                    而桶式排序却能实现O（n）的时间复杂度。但桶排序的缺点是：

                                    1）首先是空间复杂度比较高，需要的额外开销大。排序有两个数组的空间开销，一个存放待排序数组，
                                    一个就是所谓的桶，比如待排序值是从0到m-1，那就需要m个桶，这个桶数组就要至少m个空间。
                                    2）其次待排序的元素都要在一定的范围内等等。
                                    桶式排序是一种分配排序。分配排序的特定是不需要进行关键码的比较，但前提是要知道待排序列的一些具体情况。
                                </div>
                            </li>
                        </ul>
                    </li>
                </ul>
            </li>
        </ul>
    </div>
</div>
<!-- ========= END OF CLASS DATA ========= -->
<!-- ======= START OF BOTTOM NAVBAR ====== -->
<div class="bottomNav"><a name="navbar.bottom">
    <!--   -->
</a>
    <div class="skipNav"><a href="#skip.navbar.bottom" title="Skip navigation links">Skip navigation
        links</a></div>
    <a name="navbar.bottom.firstrow">
        <!--   -->
    </a>
    <ul class="navList" title="Navigation">
        <li><a href="../../../overview-summary.html">Overview</a></li>
        <li><a href="package-summary.html">Package</a></li>
        <li class="navBarCell1Rev">Class</li>
        <li><a href="package-tree.html">Tree</a></li>
        <li><a href="../../../deprecated-list.html">Deprecated</a></li>
        <li><a href="../../../index-files/index-1.html">Index</a></li>
        <li><a href="../../../help-doc.html">Help</a></li>
    </ul>
</div>
<div class="subNav">
    <ul class="navList">
        <li><a href="../../../waterhole/commonlibs/utils/SecurityUtils.html"
               title="class in waterhole.commonlibs.utils"><span class="typeNameLink">Prev&nbsp;Class</span></a>
        </li>
        <li><a href="../../../waterhole/commonlibs/utils/StringUtils.html"
               title="class in waterhole.commonlibs.utils"><span class="typeNameLink">Next&nbsp;Class</span></a>
        </li>
    </ul>
    <ul class="navList">
        <li><a href="../../../index.html?waterhole/commonlibs/utils/SortUtils.html" target="_top">Frames</a>
        </li>
        <li><a href="SortUtils.html" target="_top">No&nbsp;Frames</a></li>
    </ul>
    <ul class="navList" id="allclasses_navbar_bottom">
        <li><a href="../../../allclasses-noframe.html">All&nbsp;Classes</a></li>
    </ul>
    <div>
        <script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_bottom");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->

        </script>
    </div>
    <div>
        <ul class="subNavList">
            <li>Summary:&nbsp;</li>
            <li>Nested&nbsp;|&nbsp;</li>
            <li>Field&nbsp;|&nbsp;</li>
            <li><a href="#constructor.summary">Constr</a>&nbsp;|&nbsp;</li>
            <li><a href="#method.summary">Method</a></li>
        </ul>
        <ul class="subNavList">
            <li>Detail:&nbsp;</li>
            <li>Field&nbsp;|&nbsp;</li>
            <li><a href="#constructor.detail">Constr</a>&nbsp;|&nbsp;</li>
            <li><a href="#method.detail">Method</a></li>
        </ul>
    </div>
    <a name="skip.navbar.bottom">
        <!--   -->
    </a></div>
<!-- ======== END OF BOTTOM NAVBAR ======= -->
</body>
</html>
